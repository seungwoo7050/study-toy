# 프로그래밍 0단계 – 완전 기초 가이드

> 이 문서는 **프로그래밍을 한 번도 안 해본 사람**이 이 레포의 나머지 문서와 토이 프로젝트를 따라갈 수 있게 만들기 위한 0단계 가이드이다.

---

## 0. 이 문서로 어디까지 가는가

이 문서를 끝낼 때까지 목표:

1. **터미널**을 열고, 디렉터리를 이동하고, 폴더/파일을 다룰 수 있다.
2. **Git**으로 레포를 `clone`하고, 브랜치를/태그를 체크아웃할 수 있다.
3. **코드 에디터(예: VS Code)**로 파일을 열고 수정할 수 있다.
4. "프로그램"이 무엇인지, **입력 → 처리 → 출력** 구조를 이해한다.
5. **변수 / 조건문 / 반복문 / 함수** 같은 공통 개념을 안다. (언어별 문법은 이후 문서에서 다룬다.)
6. 에러 메시지를 봤을 때, **어디를 읽어야 하고, 어떻게 검색해야 하는지** 감이 있다.

이 정도면 이후의:

* `C++ 네트워크 프로그래밍 기초`
* `Spring Boot 기초`
* `React 기초`
* `Node.js/Express + TypeScript 기초`

문서를 따라가기에 충분하다.

---

## 1. 개발 환경 – 최소한으로 알아야 할 것들

프로그래밍할 때 항상 등장하는 것들:

1. **운영체제(OS)**

   * Windows / macOS / Linux (또는 Windows + WSL)
2. **터미널(명령줄)**

   * 명령을 텍스트로 입력해서 실행하는 창
3. **코드 에디터 / IDE**

   * VS Code, IntelliJ, CLion 등
4. **Git**

   * 코드 변경 이력을 관리하는 도구
5. **언어/런타임**

   * C++ 컴파일러, Java/JDK, Node.js 같은 것

이 문서는 **OS에 크게 의존하지 않는 공통 개념** 위주로 설명한다.
OS별 세부 설치는 각 언어별 기초 문서와 프로젝트에서 다룬다고 보고, 여기서는 "역할"만 잡고 간다.

---

## 2. 터미널 / 파일 시스템 기초

후반부 C++, Node, Spring, React 문서 전부 **터미널 사용을 전제로 한다.**
그래서 여기서 최소한은 정리해둔다.

### 2.1 현재 디렉터리와 경로

파일 시스템 개념:

* **폴더 = 디렉터리(directory)**
* **경로(path)**: 어떤 파일/폴더가 어디 있는지 나타내는 문자열

예:

* `/home/user/projects/toy-suite`
* `C:\Users\user\projects\toy-suite`

**현재 디렉터리**:
지금 터미널이 "어느 폴더 안에 있는지"를 의미한다.

### 2.2 기본 명령어

아래는 리눅스/맥/WSL 기준이다.
Windows PowerShell은 거의 비슷하지만, `ls` 대신 `dir`을 써도 된다.

```bash
# 현재 디렉터리의 전체 경로 출력
pwd

# 현재 디렉터리의 파일/폴더 목록 보기
ls

# 하위 디렉터리로 이동
cd projects
cd toy-suite

# 상위 디렉터리로 이동
cd ..

# 폴더 만들기
mkdir test-project

# 파일/폴더 삭제 (주의)
rm some-file.txt
rm -r some-folder      # 폴더 전체 삭제
rm -rf some-folder     # 강제 삭제 (실수하면 복구 거의 불가)
```

실제로 해볼 것:

1. 홈 디렉터리(보통 터미널 켜면 기본 위치)에서:

   ```bash
   mkdir dev
   cd dev
   mkdir toy-playground
   cd toy-playground
   pwd
   ```
2. `ls` 쳐서 폴더가 잘 보이는지 확인한다.

### 2.3 상대 경로 vs 절대 경로

* **절대 경로**: 루트부터 전체를 다 적은 경로

  * 예: `/home/user/dev/toy-playground`
* **상대 경로**: 현재 디렉터리를 기준으로 적는 경로

  * 예: `../other-project`, `./src`

기본 규칙:

* `.`  → 현재 디렉터리
* `..` → 상위 디렉터리

예:

```bash
cd ~/dev/toy-playground   # 절대/홈 기준
cd ../other-project       # 상대 경로
```

이 감각이 없으면, 이후 `cd` 할 때마다 길을 잃는다.
이 문서 단계에서 확실히 익혀두는 게 좋다.

---

## 3. Git – 버전 관리 최소 개념

이 레포는 학습용이지만, 실전 코드처럼 Git으로 관리된다고 가정한다.

### 3.1 Git이 하는 일

Git은:

* 코드의 **버전(스냅샷)**을 저장한다.
* "어떤 파일을 언제 어떻게 바꿨는지"를 추적한다.
* 여러 사람이 동시에 작업해도 **브랜치**로 분리했다가 나중에 합칠 수 있게 한다.

여기서는 혼자 쓴다고 가정하고 최소 개념만 잡는다.

### 3.2 레포 클론(clone)

GitHub 같은 곳에 있는 리포를 내 컴퓨터로 가져오는 명령:

```bash
git clone <레포_URL>
cd <레포_폴더명>
```

예:

```bash
git clone https://github.com/example/toy-project-suite.git
cd toy-project-suite
```

### 3.3 상태 확인

지금 작업 디렉터리의 Git 상태를 보는 명령:

```bash
git status
```

* 어떤 파일이 변경됐는지
* 커밋되지 않은 변경이 있는지

를 한눈에 볼 수 있다.

### 3.4 기본 흐름: 수정 → add → commit

1. 에디터로 파일 수정

2. 변경을 "스냅샷에 포함시키겠다"는 표시:

   ```bash
   git add 파일이름
   # 혹은
   git add .
   ```

3. 커밋(버전 하나 만들기):

   ```bash
   git commit -m "메시지"
   ```

4. 커밋 기록 보기:

   ```bash
   git log --oneline
   ```

이 레포는 학습용이라 **로컬에서만 commit을 찍고 버려도 상관없다.**
중요한 건:

* `git status`, `git log` 결과가 뭘 의미하는지만 대략 이해하는 것.

### 3.5 브랜치 / 태그 이동

프로젝트가 버전별로 나뉘어 있을 수 있다. 예를 들어:

* `BE-v0.1`, `BE-v0.2` …
* `FE-F0.1` …
* `CPP-C0.1` …

이런 이름이 **브랜치**거나 **태그**로 달려 있을 수 있다.

일반적인 이동 방법:

```bash
# 브랜치로 이동
git checkout 브랜치이름

# 태그를 체크아웃 (태그 앞에 'tags/'가 필요한 경우도 있음)
git checkout tags/태그이름
```

브랜치/태그가 실제로 무엇으로 설정되어 있는지는 레포 설명을 기준으로 한다.

---

## 4. "프로그램"이 뭔지부터 잡고 가기

추상적으로 말할 필요 없다. 최소 개념만:

### 4.1 프로그램의 구조

대부분의 프로그램은 이 구조를 가진다.

> **입력(Input) → 처리(Processing) → 출력(Output)**

예:

* 콘솔 프로그램

  * 입력: 키보드로 입력한 숫자
  * 처리: 두 숫자를 더한다
  * 출력: 결과 숫자를 화면에 보여준다
* 웹 서버(Spring/Node)

  * 입력: HTTP 요청 (URL, JSON body 등)
  * 처리: DB 조회/계산
  * 출력: HTTP 응답(JSON, HTML 등)
* 프론트엔드(React)

  * 입력: 사용자의 클릭, 입력 폼 값
  * 처리: 상태 업데이트, API 호출
  * 출력: 화면 UI 변경

어떤 언어를 쓰든 이 틀에서 벗어나지 않는다.

### 4.2 콘솔 vs 백엔드 vs 프론트엔드

* **콘솔 프로그램**

  * 터미널에서 실행
  * 입출력이 텍스트
* **백엔드**

  * 네트워크(HTTP) 요청을 받아서 처리
  * JSON / HTML 등을 반환
* **프론트엔드**

  * 브라우저에서 돌아감
  * 화면(UI)을 그리면서 API를 호출

이 레포의 토이 프로젝트들은 결국:

* C++로 콘솔/네트워크 프로그램
* Spring/Node로 백엔드
* React로 프론트엔드

를 한 번씩 경험하게 할 것이다.
0단계에서는 **"입력-처리-출력" 구조만 기억하면 된다.**

---

## 5. 언어 공통 문법 개념

각 언어 문법은 이후 문서에서 보게 된다.
여기서는 **모든 언어에 공통인 개념만** 정리한다.

예시 코드는 JavaScript 비슷한 가짜 문법으로 쓴다. (C++/Java/TypeScript 등과 구조가 거의 같다.)

### 5.1 변수(Variable)

* 값을 담는 이름 있는 상자
* "어디에 저장해 두고 나중에 다시 쓰겠다"는 의미

```text
let hp = 100
hp = hp - 30
```

개념:

* "이름 → 값" 매핑이 생긴다.
* 이름으로 값을 읽고, 다시 덮어쓸 수 있다.

### 5.2 타입(Type)

값의 종류:

* 정수: 0, 1, 2, -10 …
* 실수: 1.5, 3.14 …
* 문자열: `"hello"`, `"abc"`
* 불리언: `true`, `false`

대부분의 언어는:

* **정수**와 **실수**를 구분한다.
* 문자열은 `"` 또는 `'`로 감싼다.
* 불리언은 조건문에서 사용한다.

이후 문서에서:

* C++/Java/TypeScript는 **정적 타입 언어**
* JavaScript는 **동적 타입 언어**

라는 이야기가 나올 텐데,
지금 단계에서는 "값에 타입이 있다" 정도만 알고 있으면 된다.

### 5.3 연산자(Operator)

대표적인 것들:

* 산술 연산: `+`, `-`, `*`, `/`, `%`
* 비교 연산: `==`, `!=`, `<`, `>`, `<=`, `>=`
* 논리 연산: `&&`(그리고), `||`(또는), `!`(부정)

개념:

* 비교/논리 연산의 결과는 **불리언(true/false)** 이다.
* 조건문에서 이 불리언을 사용한다.

### 5.4 조건문(if)

조건에 따라 실행할 코드를 나누는 구조.

```text
if (hp <= 0) {
  print("Game Over")
} else {
  print("Still alive")
}
```

공통 개념:

* 괄호 안에 **조건(불리언)** 이 들어간다.
* 조건이 `true`면 if 블록 실행
* `false`면 `else` 블록 실행 (있을 경우)

대부분의 현실적인 프로그램은 조건문 투성이다.

### 5.5 반복문(for / while)

같은 작업을 여러 번 반복하는 구조.

```text
# 1부터 10까지 출력
for (i = 1; i <= 10; i = i + 1) {
  print(i)
}
```

또는

```text
# 체력이 0 될 때까지 반복
while (hp > 0) {
  print("Attack!")
  hp = hp - 10
}
```

공통 개념:

* 반복 조건이 `true`인 동안 블록이 계속 실행된다.
* 반복 내부에서 조건이 변하도록 값을 갱신해야 한다(안 그러면 무한 루프).

### 5.6 함수(Function)

입력 → 처리 → 출력 패턴을 **이름 붙인 덩어리**로 만든 것.

```text
function add(a, b) {
  return a + b
}

result = add(3, 5)   # result = 8
```

개념:

* **매개변수(파라미터)**: `a`, `b` 처럼 함수에 들어오는 값
* **반환값(return)**: 함수가 밖으로 돌려주는 값

함수는:

* **중복된 코드를 줄이고**
* **논리를 이름으로 묶어서** 읽기 쉽게 만든다.

나중에:

* 메서드, 클래스, OOP 라는 말이 나올 때도,
  결국 "함수의 묶음/조합"이라는 감각을 유지하면 헷갈릴 일이 줄어든다.

### 5.7 배열 / 리스트

같은 종류의 값을 순서대로 여러 개 담는 구조.

```text
let damages = [10, 20, 15]

print(damages[0])  # 10
print(damages[1])  # 20
```

개념:

* 인덱스(index)는 대부분 0부터 시작한다.
* 길이(length)를 넘어가는 인덱스를 쓰면 에러, 또는 이상한 값이 나온다.

이후:

* C++: 배열, `std::vector`
* Java/TypeScript: 배열, `List`

등으로 구체적으로 들어가게 된다.

---

## 6. 에러와 디버깅 – 겁먹지 말고 읽는 법

코드를 조금만 건드리면 **에러**는 무조건 발생한다.
0단계에서 알아야 할 것은 딱 세 가지다.

### 6.1 에러의 세 종류

1. **컴파일 에러**

   * "문법이 이상하다"는 에러
   * 예: 괄호가 빠짐, 세미콜론 누락, 잘못된 타입 사용
   * 대부분 "파일이름:줄번호:에러메시지" 형태로 뜬다.
2. **런타임 에러**

   * 코드는 실행되지만, 중간에 터지는 에러
   * 예: 0으로 나누기, 없는 파일 열기, null 접근
3. **논리 에러**

   * 에러 메시지는 안 뜨는데, 결과가 의도와 다름
   * 디버깅으로 찾아야 한다.

### 6.2 에러 메시지 읽는 최소 원칙

1. **제일 위가 아니라 "중간의 중요한 줄"을 읽는다.**

   * 보통 스택 트레이스 중간에 **내 코드 파일 이름**이 적힌 줄이 핵심이다.
2. 적어도 다음은 눈에 익혀둔다.

   * 파일 이름
   * 줄 번호
   * 에러 종류/메시지 (예: `NullPointerException`, `TypeError`, `SyntaxError`, `Segmentation fault` 등)

### 6.3 검색하기

에러는 **검색해서 해결하는 능력**이 절반이다.

방법:

1. 에러 메시지에서 **언어/프레임워크 이름 + 핵심 단어**만 뽑는다.

   * 예: `spring boot 401 unauthorized jwt`, `nodejs ECONNREFUSED`, `c++ segmentation fault vector`
2. 그대로 구글/검색엔진에 붙여 넣는다.
3. 공식 문서/StackOverflow/블로그 글을 읽으면서,
   "내 상황과 같은 부분"을 찾는다.

0단계에서 중요한 건:

* "에러가 나면 검색한다"는 습관을 미리 들이는 것
* 에러를 **감정적인 실패가 아니라, 정보 제공 장치**로 취급하는 것

---

## 7. 이 레포에서 0단계 이후의 연결

이제 이 정도 감각이 생겼다고 가정한다.

* 터미널에서 **폴더 이동/생성** 정도는 할 수 있다.
* Git으로 레포 **clone**하고, **브랜치/태그를 옮겨 다닐 수 있다.**
* "입력-처리-출력" 구조, 변수/조건/반복/함수/배열 개념은 알고 있다.
* 에러 메시지가 뜨면 **파일/줄번호/에러명** 정도는 읽어볼 수 있다.

그 다음은 영역별 기초 문서를 순서대로 보면 된다:

1. **웹 백엔드 쪽으로 먼저 갈 거면**

   * `Spring Boot 기초 학습 문서`
   * 또는 `Node.js / Express + TypeScript 기초 문서`
2. **프론트엔드 UI 쪽을 먼저 보고 싶으면**

   * `React 기초 학습 문서`
3. **언어/시스템 기초를 단단히 하고 싶으면**

   * `C++ 네트워크 프로그래밍 기초 문서`
     (여기서 C++ 문법/클래스/네트워크 개념까지 들어간다)

이 문서는 더 이상 "추가 파트"가 붙지 않는 **0단계 기준선**으로 생각하면 된다.
이 기준선에 도달하지 않은 사람에게는 이 문서를 먼저 읽으라고 안내하고,
도달한 사람에겐 바로 스택별 문서를 보라고 하면 된다.
